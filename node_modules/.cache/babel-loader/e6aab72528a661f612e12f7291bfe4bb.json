{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\yashj\\\\OneDrive\\\\Desktop\\\\pathFinderVisualizer\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nvar _jsxFileName = \"C:\\\\Users\\\\yashj\\\\OneDrive\\\\Desktop\\\\pathFinderVisualizer\\\\src\\\\PathfindingVisualizer\\\\PathfindingVisualizer.jsx\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra } from '../algorithms/dijkstra';\nimport { dfs } from '../algorithms/dfs';\nimport { bfs } from '../algorithms/bfs';\nimport './PathfindingVisualizer.css';\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n\n    this.getInitialGrid = (rowCount = this.state.ROW_COUNT, colCount = this.state.COLUMN_COUNT) => {\n      const initialGrid = [];\n\n      for (let row = 0; row < rowCount; row++) {\n        const currentRow = [];\n\n        for (let col = 0; col < colCount; col++) {\n          currentRow.push(this.createNode(row, col));\n        }\n\n        initialGrid.push(currentRow);\n      }\n\n      return initialGrid;\n    };\n\n    this.createNode = (row, col) => {\n      return {\n        row,\n        col,\n        isStart: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n        isFinish: row === this.state.FINISH_NODE_ROW && col === this.state.FINISH_NODE_COL,\n        distance: Infinity,\n        distanceToFinishNode: Math.abs(this.state.FINISH_NODE_ROW - row) + Math.abs(this.state.FINISH_NODE_COL - col),\n        isVisited: false,\n        isWall: false,\n        previousNode: null,\n        isNode: true\n      };\n    };\n\n    this.state = {\n      grid: [],\n      START_NODE_ROW: 5,\n      FINISH_NODE_ROW: 5,\n      START_NODE_COL: 5,\n      FINISH_NODE_COL: 15,\n      mouseIsPressed: false,\n      ROW_COUNT: 25,\n      COLUMN_COUNT: 35,\n      MOBILE_ROW_COUNT: 10,\n      MOBILE_COLUMN_COUNT: 20,\n      isRunning: false,\n      isStartNode: false,\n      isFinishNode: false,\n      isWallNode: false,\n      // xxxxxxx\n      currRow: 0,\n      currCol: 0,\n      isDesktopView: true\n    };\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n  }\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({\n      grid\n    });\n  }\n\n  toggleIsRunning() {\n    this.setState({\n      isRunning: !this.state.isRunning\n    });\n  }\n\n  toggleView() {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.clearWalls();\n      const isDesktopView = !this.state.isDesktopView;\n      let grid;\n\n      if (isDesktopView) {\n        grid = this.getInitialGrid(this.state.ROW_COUNT, this.state.COLUMN_COUNT);\n        this.setState({\n          isDesktopView,\n          grid\n        });\n      } else {\n        if (this.state.START_NODE_ROW > this.state.MOBILE_ROW_COUNT || this.state.FINISH_NODE_ROW > this.state.MOBILE_ROW_COUNT || this.state.START_NODE_COL > this.state.MOBILE_COLUMN_COUNT || this.state.FINISH_NODE_COL > this.state.MOBILE_COLUMN_COUNT) {\n          alert('Start & Finish Nodes Must Be within 10 Rows x 20 Columns');\n        } else {\n          grid = this.getInitialGrid(this.state.MOBILE_ROW_COUNT, this.state.MOBILE_COLUMN_COUNT);\n          this.setState({\n            isDesktopView,\n            grid\n          });\n        }\n      }\n    }\n  }\n  /******************** Set up the initial grid ********************/\n\n\n  /******************** Control mouse events ********************/\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      if (this.isGridClear()) {\n        if (document.getElementById(\"node-\".concat(row, \"-\").concat(col)).className === 'node node-start') {\n          this.setState({\n            mouseIsPressed: true,\n            isStartNode: true,\n            currRow: row,\n            currCol: col\n          });\n        } else if (document.getElementById(\"node-\".concat(row, \"-\").concat(col)).className === 'node node-finish') {\n          this.setState({\n            mouseIsPressed: true,\n            isFinishNode: true,\n            currRow: row,\n            currCol: col\n          });\n        } else {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid,\n            mouseIsPressed: true,\n            isWallNode: true,\n            currRow: row,\n            currCol: col\n          });\n        }\n      } else {\n        this.clearGrid();\n      }\n    }\n  }\n\n  isGridClear() {\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        const nodeClassName = document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className;\n\n        if (nodeClassName === 'node node-visited' || nodeClassName === 'node node-shortest-path') {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (this.state.mouseIsPressed) {\n        const nodeClassName = document.getElementById(\"node-\".concat(row, \"-\").concat(col)).className;\n\n        if (this.state.isStartNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevStartNode = this.state.grid[this.state.currRow][this.state.currCol];\n            prevStartNode.isStart = false;\n            document.getElementById(\"node-\".concat(this.state.currRow, \"-\").concat(this.state.currCol)).className = 'node';\n            this.setState({\n              currRow: row,\n              currCol: col\n            });\n            const currStartNode = this.state.grid[row][col];\n            currStartNode.isStart = true;\n            document.getElementById(\"node-\".concat(row, \"-\").concat(col)).className = 'node node-start';\n          }\n\n          this.setState({\n            START_NODE_ROW: row,\n            START_NODE_COL: col\n          });\n        } else if (this.state.isFinishNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevFinishNode = this.state.grid[this.state.currRow][this.state.currCol];\n            prevFinishNode.isFinish = false;\n            document.getElementById(\"node-\".concat(this.state.currRow, \"-\").concat(this.state.currCol)).className = 'node';\n            this.setState({\n              currRow: row,\n              currCol: col\n            });\n            const currFinishNode = this.state.grid[row][col];\n            currFinishNode.isFinish = true;\n            document.getElementById(\"node-\".concat(row, \"-\").concat(col)).className = 'node node-finish';\n          }\n\n          this.setState({\n            FINISH_NODE_ROW: row,\n            FINISH_NODE_COL: col\n          });\n        } else if (this.state.isWallNode) {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid\n          });\n        }\n      }\n    }\n  }\n\n  handleMouseUp(row, col) {\n    if (!this.state.isRunning) {\n      this.setState({\n        mouseIsPressed: false\n      });\n\n      if (this.state.isStartNode) {\n        const isStartNode = !this.state.isStartNode;\n        this.setState({\n          isStartNode,\n          START_NODE_ROW: row,\n          START_NODE_COL: col\n        });\n      } else if (this.state.isFinishNode) {\n        const isFinishNode = !this.state.isFinishNode;\n        this.setState({\n          isFinishNode,\n          FINISH_NODE_ROW: row,\n          FINISH_NODE_COL: col\n        });\n      }\n\n      this.getInitialGrid();\n    }\n  }\n\n  handleMouseLeave() {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({\n        isStartNode,\n        mouseIsPressed: false\n      });\n    } else if (this.state.isFinishNode) {\n      const isFinishNode = !this.state.isFinishNode;\n      this.setState({\n        isFinishNode,\n        mouseIsPressed: false\n      });\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({\n        isWallNode,\n        mouseIsPressed: false\n      });\n      this.getInitialGrid();\n    }\n  }\n  /******************** Clear Board/Walls ********************/\n\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className;\n\n          if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish' && nodeClassName !== 'node node-wall') {\n            document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node';\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = Math.abs(this.state.FINISH_NODE_ROW - node.row) + Math.abs(this.state.FINISH_NODE_COL - node.col);\n          }\n\n          if (nodeClassName === 'node node-finish') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = 0;\n          }\n\n          if (nodeClassName === 'node node-start') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = Math.abs(this.state.FINISH_NODE_ROW - node.row) + Math.abs(this.state.FINISH_NODE_COL - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n\n  clearWalls() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className;\n\n          if (nodeClassName === 'node node-wall') {\n            document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node';\n            node.isWall = false;\n          }\n        }\n      }\n    }\n  }\n  /******************** Create Animations ********************/\n\n\n  visualize(algo) {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.toggleIsRunning();\n      const grid = this.state.grid;\n      const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n      const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n      let visitedNodesInOrder;\n\n      switch (algo) {\n        case 'Dijkstra':\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n          break;\n\n        case 'BFS':\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\n          break;\n\n        case 'DFS':\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\n          break;\n\n        default:\n          // should never get here\n          break;\n      }\n\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n      nodesInShortestPathOrder.push('end');\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n  }\n\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeClassName = document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className;\n\n        if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish') {\n          document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node node-visited';\n        }\n      }, 10 * i);\n    }\n  }\n  /******************** Create path from start to finish ********************/\n\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      if (nodesInShortestPathOrder[i] === 'end') {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 50);\n      } else {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          const nodeClassName = document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className;\n\n          if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish') {\n            document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node node-shortest-path';\n          }\n        }, i * 40);\n      }\n    }\n  }\n\n  render() {\n    const _this$state = this.state,\n          grid = _this$state.grid,\n          mouseIsPressed = _this$state.mouseIsPressed;\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 394\n      },\n      __self: this\n    }, React.createElement(\"nav\", {\n      className: \"navbar navbar-expand-lg navbar-dark bg-primary text-center\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 395\n      },\n      __self: this\n    }, React.createElement(\"a\", {\n      className: \"navbar-brand\",\n      href: \"/\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 396\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 397\n      },\n      __self: this\n    }, \"PathFinding Visualizer\")), React.createElement(\"button\", {\n      className: \"navbar-toggler\",\n      type: \"button\",\n      \"data-toggle\": \"collapse\",\n      \"data-target\": \"#navbarNav\",\n      \"aria-controls\": \"navbarNav\",\n      \"aria-expanded\": \"false\",\n      \"aria-label\": \"Toggle navigation\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 399\n      },\n      __self: this\n    }, React.createElement(\"span\", {\n      className: \"navbar-toggler-icon\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 407\n      },\n      __self: this\n    }))), React.createElement(\"table\", {\n      className: \"grid-container\",\n      onMouseLeave: () => this.handleMouseLeave(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 411\n      },\n      __self: this\n    }, React.createElement(\"tbody\", {\n      className: \"grid\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 414\n      },\n      __self: this\n    }, grid.map((row, rowIdx) => {\n      return React.createElement(\"tr\", {\n        key: rowIdx,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 417\n        },\n        __self: this\n      }, row.map((node, nodeIdx) => {\n        const row = node.row,\n              col = node.col,\n              isFinish = node.isFinish,\n              isStart = node.isStart,\n              isWall = node.isWall;\n        return React.createElement(Node, {\n          key: nodeIdx,\n          col: col,\n          isFinish: isFinish,\n          isStart: isStart,\n          isWall: isWall,\n          mouseIsPressed: mouseIsPressed,\n          onMouseDown: (row, col) => this.handleMouseDown(row, col),\n          onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n          onMouseUp: () => this.handleMouseUp(row, col),\n          row: row,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 421\n          },\n          __self: this\n        });\n      }));\n    }))), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-danger\",\n      onClick: () => this.clearGrid(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 443\n      },\n      __self: this\n    }, \"Clear Grid\"), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-warning\",\n      onClick: () => this.clearWalls(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 449\n      },\n      __self: this\n    }, \"Clear Walls\"), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-primary\",\n      onClick: () => this.visualize('Dijkstra'),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 455\n      },\n      __self: this\n    }, \"Dijkstra's\"), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-primary\",\n      onClick: () => this.visualize('BFS'),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 461\n      },\n      __self: this\n    }, \"Breadth First Search\"), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-primary\",\n      onClick: () => this.visualize('DFS'),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 467\n      },\n      __self: this\n    }, \"Depth First Search\"), this.state.isDesktopView ? React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-light\",\n      onClick: () => this.toggleView(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 474\n      },\n      __self: this\n    }, \"Mobile View\") : React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-dark\",\n      onClick: () => this.toggleView(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 481\n      },\n      __self: this\n    }, \"Desktop View\"));\n  }\n\n}\n/******************** Create Walls ********************/\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n\n  if (!node.isStart && !node.isFinish && node.isNode) {\n    const newNode = _objectSpread({}, node, {\n      isWall: !node.isWall\n    });\n\n    newGrid[row][col] = newNode;\n  }\n\n  return newGrid;\n}; // Backtracks from the finishNode to find the shortest path.\n// Only works when called after the pathfinding methods.\n\n\nfunction getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["C:\\Users\\yashj\\OneDrive\\Desktop\\pathFinderVisualizer\\src\\PathfindingVisualizer\\PathfindingVisualizer.jsx"],"names":["React","Component","Node","dijkstra","dfs","bfs","PathfindingVisualizer","constructor","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","row","currentRow","col","push","createNode","isStart","START_NODE_ROW","START_NODE_COL","isFinish","FINISH_NODE_ROW","FINISH_NODE_COL","distance","Infinity","distanceToFinishNode","Math","abs","isVisited","isWall","previousNode","isNode","grid","mouseIsPressed","MOBILE_ROW_COUNT","MOBILE_COLUMN_COUNT","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","isDesktopView","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","componentDidMount","setState","toggleView","clearGrid","clearWalls","alert","isGridClear","document","getElementById","className","newGrid","getNewGridWithWallToggled","node","nodeClassName","handleMouseEnter","prevStartNode","currStartNode","prevFinishNode","currFinishNode","handleMouseUp","slice","visualize","algo","startNode","finishNode","visitedNodesInOrder","nodesInShortestPathOrder","getNodesInShortestPathOrder","animate","i","length","setTimeout","animateShortestPath","render","map","rowIdx","nodeIdx","newNode","currentNode","unshift"],"mappings":"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","sourcesContent":["import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport {dijkstra} from '../algorithms/dijkstra';\r\nimport {dfs} from '../algorithms/dfs';\r\nimport {bfs} from '../algorithms/bfs';\r\n\r\nimport './PathfindingVisualizer.css';\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      START_NODE_ROW: 5,\r\n      FINISH_NODE_ROW: 5,\r\n      START_NODE_COL: 5,\r\n      FINISH_NODE_COL: 15,\r\n      mouseIsPressed: false,\r\n      ROW_COUNT: 25,\r\n      COLUMN_COUNT: 35,\r\n      MOBILE_ROW_COUNT: 10,\r\n      MOBILE_COLUMN_COUNT: 20,\r\n      isRunning: false,\r\n      isStartNode: false,\r\n      isFinishNode: false,\r\n      isWallNode: false, // xxxxxxx\r\n      currRow: 0,\r\n      currCol: 0,\r\n      isDesktopView: true,\r\n    };\r\n\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({grid});\r\n  }\r\n\r\n  toggleIsRunning() {\r\n    this.setState({isRunning: !this.state.isRunning});\r\n  }\r\n\r\n  toggleView() {\r\n    if (!this.state.isRunning) {\r\n      this.clearGrid();\r\n      this.clearWalls();\r\n      const isDesktopView = !this.state.isDesktopView;\r\n      let grid;\r\n      if (isDesktopView) {\r\n        grid = this.getInitialGrid(\r\n          this.state.ROW_COUNT,\r\n          this.state.COLUMN_COUNT,\r\n        );\r\n        this.setState({isDesktopView, grid});\r\n      } else {\r\n        if (\r\n          this.state.START_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\r\n          this.state.FINISH_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\r\n          this.state.START_NODE_COL > this.state.MOBILE_COLUMN_COUNT ||\r\n          this.state.FINISH_NODE_COL > this.state.MOBILE_COLUMN_COUNT\r\n        ) {\r\n          alert('Start & Finish Nodes Must Be within 10 Rows x 20 Columns');\r\n        } else {\r\n          grid = this.getInitialGrid(\r\n            this.state.MOBILE_ROW_COUNT,\r\n            this.state.MOBILE_COLUMN_COUNT,\r\n          );\r\n          this.setState({isDesktopView, grid});\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /******************** Set up the initial grid ********************/\r\n  getInitialGrid = (\r\n    rowCount = this.state.ROW_COUNT,\r\n    colCount = this.state.COLUMN_COUNT,\r\n  ) => {\r\n    const initialGrid = [];\r\n    for (let row = 0; row < rowCount; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < colCount; col++) {\r\n        currentRow.push(this.createNode(row, col));\r\n      }\r\n      initialGrid.push(currentRow);\r\n    }\r\n    return initialGrid;\r\n  };\r\n\r\n  createNode = (row, col) => {\r\n    return {\r\n      row,\r\n      col,\r\n      isStart:\r\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n      isFinish:\r\n        row === this.state.FINISH_NODE_ROW &&\r\n        col === this.state.FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      distanceToFinishNode:\r\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\r\n        Math.abs(this.state.FINISH_NODE_COL - col),\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      isNode: true,\r\n    };\r\n  };\r\n\r\n  /******************** Control mouse events ********************/\r\n  handleMouseDown(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.isGridClear()) {\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-start'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isStartNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        } else if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-finish'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isFinishNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        } else {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n          this.setState({\r\n            grid: newGrid,\r\n            mouseIsPressed: true,\r\n            isWallNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        }\r\n      } else {\r\n        this.clearGrid();\r\n      }\r\n    }\r\n  }\r\n\r\n  isGridClear() {\r\n    for (const row of this.state.grid) {\r\n      for (const node of row) {\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className;\r\n        if (\r\n          nodeClassName === 'node node-visited' ||\r\n          nodeClassName === 'node node-shortest-path'\r\n        ) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.state.mouseIsPressed) {\r\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\r\n          .className;\r\n        if (this.state.isStartNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevStartNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevStartNode.isStart = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node';\r\n\r\n            this.setState({currRow: row, currCol: col});\r\n            const currStartNode = this.state.grid[row][col];\r\n            currStartNode.isStart = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-start';\r\n          }\r\n          this.setState({START_NODE_ROW: row, START_NODE_COL: col});\r\n        } else if (this.state.isFinishNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevFinishNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevFinishNode.isFinish = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node';\r\n\r\n            this.setState({currRow: row, currCol: col});\r\n            const currFinishNode = this.state.grid[row][col];\r\n            currFinishNode.isFinish = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-finish';\r\n          }\r\n          this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col});\r\n        } else if (this.state.isWallNode) {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n          this.setState({grid: newGrid});\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    if (!this.state.isRunning) {\r\n      this.setState({mouseIsPressed: false});\r\n      if (this.state.isStartNode) {\r\n        const isStartNode = !this.state.isStartNode;\r\n        this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col});\r\n      } else if (this.state.isFinishNode) {\r\n        const isFinishNode = !this.state.isFinishNode;\r\n        this.setState({\r\n          isFinishNode,\r\n          FINISH_NODE_ROW: row,\r\n          FINISH_NODE_COL: col,\r\n        });\r\n      }\r\n      this.getInitialGrid();\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.state.isStartNode) {\r\n      const isStartNode = !this.state.isStartNode;\r\n      this.setState({isStartNode, mouseIsPressed: false});\r\n    } else if (this.state.isFinishNode) {\r\n      const isFinishNode = !this.state.isFinishNode;\r\n      this.setState({isFinishNode, mouseIsPressed: false});\r\n    } else if (this.state.isWallNode) {\r\n      const isWallNode = !this.state.isWallNode;\r\n      this.setState({isWallNode, mouseIsPressed: false});\r\n      this.getInitialGrid();\r\n    }\r\n  }\r\n\r\n  /******************** Clear Board/Walls ********************/\r\n\r\n  clearGrid() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish' &&\r\n            nodeClassName !== 'node node-wall'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n          }\r\n          if (nodeClassName === 'node node-finish') {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode = 0;\r\n          }\r\n          if (nodeClassName === 'node node-start') {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n            node.isStart = true;\r\n            node.isWall = false;\r\n            node.previousNode = null;\r\n            node.isNode = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clearWalls() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (nodeClassName === 'node node-wall') {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n            node.isWall = false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /******************** Create Animations ********************/\r\n  visualize(algo) {\r\n    if (!this.state.isRunning) {\r\n      this.clearGrid();\r\n      this.toggleIsRunning();\r\n      const {grid} = this.state;\r\n      const startNode =\r\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n      const finishNode =\r\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n      let visitedNodesInOrder;\r\n      switch (algo) {\r\n        case 'Dijkstra':\r\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n          break;\r\n        case 'BFS':\r\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n          break;\r\n        case 'DFS':\r\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n          break;\r\n        default:\r\n          // should never get here\r\n          break;\r\n      }\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      nodesInShortestPathOrder.push('end');\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n  }\r\n\r\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className;\r\n        if (\r\n          nodeClassName !== 'node node-start' &&\r\n          nodeClassName !== 'node node-finish'\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-visited';\r\n        }\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  /******************** Create path from start to finish ********************/\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      if (nodesInShortestPathOrder[i] === 'end') {\r\n        setTimeout(() => {\r\n          this.toggleIsRunning();\r\n        }, i * 50);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          const nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-shortest-path';\r\n          }\r\n        }, i * 40);\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state;\r\n    return (\r\n      <div>\r\n        <nav className=\"navbar navbar-expand-lg navbar-dark bg-primary text-center\">\r\n          <a className=\"navbar-brand\" href=\"/\">\r\n            <b>PathFinding Visualizer</b>\r\n          </a>\r\n          <button\r\n            className=\"navbar-toggler\"\r\n            type=\"button\"\r\n            data-toggle=\"collapse\"\r\n            data-target=\"#navbarNav\"\r\n            aria-controls=\"navbarNav\"\r\n            aria-expanded=\"false\"\r\n            aria-label=\"Toggle navigation\">\r\n            <span className=\"navbar-toggler-icon\"></span>\r\n          </button>\r\n        </nav>\r\n\r\n        <table\r\n          className=\"grid-container\"\r\n          onMouseLeave={() => this.handleMouseLeave()}>\r\n          <tbody className=\"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <tr key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const {row, col, isFinish, isStart, isWall} = node;\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        col={col}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) =>\r\n                          this.handleMouseDown(row, col)\r\n                        }\r\n                        onMouseEnter={(row, col) =>\r\n                          this.handleMouseEnter(row, col)\r\n                        }\r\n                        onMouseUp={() => this.handleMouseUp(row, col)}\r\n                        row={row}></Node>\r\n                    );\r\n                  })}\r\n                </tr>\r\n              );\r\n            })}\r\n          </tbody>\r\n        </table>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-danger\"\r\n          onClick={() => this.clearGrid()}>\r\n          Clear Grid\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-warning\"\r\n          onClick={() => this.clearWalls()}>\r\n          Clear Walls\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.visualize('Dijkstra')}>\r\n          Dijkstra's\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.visualize('BFS')}>\r\n          Breadth First Search\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.visualize('DFS')}>\r\n          Depth First Search\r\n        </button>\r\n        {this.state.isDesktopView ? (\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-light\"\r\n            onClick={() => this.toggleView()}>\r\n            Mobile View\r\n          </button>\r\n        ) : (\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-dark\"\r\n            onClick={() => this.toggleView()}>\r\n            Desktop View\r\n          </button>\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n/******************** Create Walls ********************/\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  if (!node.isStart && !node.isFinish && node.isNode) {\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n  }\r\n  return newGrid;\r\n};\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called after the pathfinding methods.\r\nfunction getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}